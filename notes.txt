Notes
-----

Wondering why my test waveform isn't identical to my cosine wave form. I
calculate the period in the same way.

ANSWER: I was using the 'float' version of the cos/sin functions in
one case (add_cos) and the 'double' version of them in the test case
(add_test) so basically double the dynamic range. Fixing that gets
them a lot closer, but the test one has better "nominal" dynamic range,
its noise is around -300 dB but it has spurs up to -220DB, whereas the
one using the functions directly has its noise at -250 dB with no spurs
really in the -220 range.

So one question answered, and another created.

Then we have the question of the 'infinity' answers on the FFT when the
function is exactly 1/8th the FFT bins. That is a different question.

New problem: Changing the sample rate to 10000 generates a *very* odd FFT
plot. It looks very much like something with very wide skirts. Although
the phase noise should not be that bad.

ANSWER: This is spectral leakage.

With an 8912 sample rate I get the expected FFT, with a 10000 sample
rate, I get a very weird FFT. What is more, the frequency along the
bottom doesn't seem to change (but that might be part of the problem)

That said, the test wave form and trancendental generated waveform
generate the EXACT same FFT (which is something I would expect) except
they just barely touch 0 dB after going up to 60 dB.

Moving the sample rate to 10240 gets a back to an "expected" FFT (one
peak, a lot of noise in the -220 to -300 dB range.

Frequency and sample rate are interacting in a very very weird way. I
expect I'm using sample rate when I should be using bins in my FFT
calculation.

ANSWER: This creates spectral "leakage" when the frequency doesn't land
completely within the FFT bin. Its spillage raises everything. Can be
remediated somewhat with windows.

Added Hann window and Blackman-Harris window. Not sure if I can figure
out a Kaiser-Bessleman window. These two are pretty good and serve to
illustrate the problem and the fix.

Add DFT code and examples.

So article outline:
	Who the article is for (not for Matlab geeks)
	Correlation as a way to "pick out" frequencies in a signal.
	Slewing a sinusoid from DC to 'N' to map out sinusoids, the DFT
	Linear vs Log plotting, dynamic range
	Signals and Harmonics - what makes a waveform a waveform?
	Doing that "Fast" with the Fast Fourier Transform
	Gotchas and Spectral Leakage
	Adding a "window" to the FFT
		The Hann window
		The Blackman-Harris 4 element window
	Conclusions and next steps.

I'm thinking I should move the window functions to their own .c and .h
files. *DONE*

Down sampling to get IQ data from REAL data.

Tasks:
	Generate 4x data
	Take the FFT and show it with the images on the "other" side.
	Downsample x4
		low pass filter
		decimate
	Take the FFT and show only our desired waveforms have come through.

This taken from Chapter 6 on Practical Applications in DSP.
Show frequencies over the passband target are eliminated
Show frequenices near the passband are passed.

----------------
DFT questions

New dft code from the internet. Looking to see if we can "zoom" it so that
we can compute the DFT for a filter and have the expected result.

First, verify it works as we expect for a sample rate width sample.
Then, verify it works for a 34 element sample.
Then, zoom it too 100 points for the 34 element sample.
Finally, zoom it to 500 points for the 34 element sample.

Other FIR notes

An average of 'n' bins is essentially and array of taps each
holding the value 1/n. 

The impulse response is to smear an impulse over 'n' bins. 

Starting from that lets see if we can work up filters a different
way.

DFT Summary - Fill with zeros don't upsample. Taking the impulse response
of a filter and computing the DFT (adding zeros after you run out of tap
values) plots the frequency response of the filter, normalized to sample
rate. 

My DFT code, and the internet DFT code is identical, caveat I split the
e^-jwkt/n term into sin and cos terms for the complex number. The internet
code uses the complex exponential (which I didn't realize we had!) Mine
saves multiplies.

Two ways to write it:
1) the complex exponential e^-jwkt/bins
2) the incremental angle cos(wt*k/bins) - sin(wt*k/bins) I

They should be identical, and one way leads to a lot less work.
So a quick test program to see if we can prove this numerically.

And they are, as I've proven to myself. So now to make "slightly"
faster DFT code.

Signals
-------

So for the tool box I've just been generating signals, but it might
be nice to be able to read in an iq file, if I had a standard format
that I could use, and perhaps a directory 'signals' ? Something to
consider.

The TP3 experiment was a failure, The image signal persists.

The TP4 experiment suggests I should be able to simply read and write
doubles to disk. A good way to examin files is with
hexdump -e '8/1 "%02X ""\n"' <file> | head -25 > <save.file>

Signal storing and loading for anything other than doubles is
broken horribly. I'm not sure exactly how I expected it to work
but it doesn't work at all.

Plotting
--------

I really need a plotter. I am thinking something like:
int plot(FILE *file, char *name, signal_buffer *b, Y_NORM/Y_DB, X_NORM/X_FREQ/X_TIME);

This then writes into file :
$plot_%d << EOD
[normalized|frequency|time] name
<value> <value>
...
EOD

Returns a number of the plot, so that later it can be referred to
as 'plot $plot_<n> using 1:2 with lines'

Negative frequency shifting
---------------------------
The complex frequency -fs/4 = [1 + 0i, 0 + -1i, -1 + 0i, 0 + 1i]

TP5 - gets the frequency back but it is the complex conjugate of the original
which is kind of weird.
