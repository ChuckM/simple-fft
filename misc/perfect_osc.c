/*
 * Experiment -- Generate a datastructure that holds harmonic oscillator
 *               points for a perfect oscillator
 *
 * It importantly doesn't depend on anything else so that it can be compiled
 * and run as part of building everything.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>

/* The amplitude of choice */
#define AMPLITUDE	16384
int
main(int argc, char *argv[]) {

	double rad, cur_rad;
	int16_t px, py;
	double ea, ex, ey, dx, dy;
	double max_ea, max_ex, max_ey;
	double min_ea, min_ex, min_ey;
	int num_refs;
	double len;
	int gen_code = 0;
	FILE *of;

	max_ea = max_ex = max_ey = 0;
	min_ea = min_ex = min_ey = 0;

	/*
	 * The smallest radian that would cause the X,Y position to change, is
	 * one 'unit' up, and full length long 
	 */
	len = sqrt(AMPLITUDE*AMPLITUDE + 1);
	// printf("Length of the hyp of our triangle: %f\n", len);
	rad = asin(1.0/len);

	if (strstr(argv[1], ".c") != NULL) {
		gen_code = 1;
	} else if (strstr(argv[1],".h") != NULL) {
		gen_code = 0;
	} else {
		fprintf(stderr, "Must specify a .c file or .h file on the command line\n");
		exit(1);
	}

	of = fopen(argv[1], "w");
	if (gen_code) {
		fprintf(of,
			"/*\n"
			" * %s - data structure holding coordinates for a circle\n"
			" * **** GENERATED BY perfect_osc.c DO NOT EDIT ****\n"
			" */\n"
			"#include <dsp/ho_refs.h>\n\n"
			"ref_t refs[] = {\n", argv[1]);
	} else {
		fprintf(of,
			"/*\n"
			" * Harmonic Oscillator Definitions\n"
			" * **** GENERATED BY perfect_osc.c DO NOT EDIT ****\n"
			" */\n\n"
			"#pragma once\n"
			"#include <stdint.h>\n"
			"#define REFS_MIN_RADIAN %10.8f\n\n", rad);
		fprintf(of,
			"typedef struct {\n"
			"    double radians;\n"
   			"    int16_t x;\n"
			"    int16_t y;\n"
			"} ref_t;\n\n"
		);
	}
	px = 0;
	py = 16384;
	cur_rad = 0;
	num_refs = 0;
	while (cur_rad <= (2 * M_PI + rad)) {
		double x, y;
		int16_t xi, yi;
		double t, f;

		x = AMPLITUDE * sin(cur_rad);
		y = AMPLITUDE * cos(cur_rad);
		xi = (int16_t) round(x);
		yi = (int16_t) round(y);
		cur_rad += rad;
		if ((abs(xi-px) > 1) || (abs(yi-py) > 1)) {
			printf("GAP at %d\n", xi);
			printf("      Radians: %f\n"
				   "    prev X, Y: %d, %d\n"
				   " current X, Y: %d, %d\n",
				cur_rad - rad, px, py, xi, yi);
			fclose(of);
			exit(1);
		}
		if ((xi ==  px) && (yi == py)) {
			/*
			 * This IFDEF'd  out because it's harmless
			 * but GAPs, those are a problem.
			 */
#if 0
			printf("DUP at %d\n", xi);
			printf("DUP at %d\n", xi);
			printf("      Radians: %f\n"
		 		   "    prev X, Y: %d, %d\n"
		 		   " current X, Y: %d, %d\n",
		 		cur_rad - rad, px, py, xi, yi);
#endif
			continue;
		}
		px = xi;
		py = yi;
		/* actual radius and actual angle */
		double act_r = sqrt(xi * xi + yi * yi);
		double act_a = asin(xi / act_r);

		num_refs++;
		if (gen_code) {

			fprintf(of, "    { %10.7f, %5d, %5d },", cur_rad - rad, xi, yi);
			ex = x - xi;		// Fractional part of X
			ey = y - yi;		// Fractional part of Y
			ea = AMPLITUDE - act_r;		// Fractional part of amplitude.
			fprintf(of, "// (Ae, Xe, Ye) => %6.5f, %6.5f, %6.5f\n",
				ea, ex, ey);
			max_ex = (ex >= max_ex) ? ex : max_ex;
			max_ey = (ey >= max_ey) ? ey : max_ey;
			max_ea = (ea >= max_ea) ? ea : max_ea;
			min_ex = (ex <= min_ex) ? ex : min_ex;
			min_ey = (ey <= min_ex) ? ey : min_ey;
			min_ea = (ea <= min_ea) ? ea : min_ea;

		}
	}
	if (gen_code) {
		fprintf(of, "};\n");
		fprintf(of, "/*\n"
					" * Error limits: \n"
					" *    min/max X error : %6.5f / %6.5f\n"
					" *    min/max Y error : %6.5f / %6.5f\n"
					" *    min/max A error : %6.5f / %6.5f\n"
					" */\n",
					min_ex, max_ex, min_ey, max_ey, min_ea, max_ea);
	} else {
		fprintf(of, 
			"#define REFS_MAX_REF	%d\n"
			"extern ref_t refs[REFS_MAX_REF];\n", num_refs);
	}
	fclose(of);
}
